"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var fs = require("fs");
var path = require("path");
var controller_1 = require("../controller");
var utils_1 = require("../../utils");
var const_1 = require("../../const");
var types_1 = require("../../types");
var urlParse = require('url-parse');
var cluster = null;
var MultiThreadUploadController = /** @class */ (function (_super) {
    __extends(MultiThreadUploadController, _super);
    function MultiThreadUploadController(uploadData) {
        var _this = _super.call(this, uploadData) || this;
        try {
            cluster = require('cluster');
            if (fs.existsSync) {
                var jsWorkerPath = path.join(__dirname, "/worker.js");
                var tsWorkerPath = path.join(__dirname, "/worker.ts");
                cluster.setupMaster({
                    exec: fs.existsSync(jsWorkerPath) ? jsWorkerPath : tsWorkerPath
                });
            }
        }
        catch (e) {
            _this.log(e);
        }
        return _this;
    }
    MultiThreadUploadController.prototype.healthCheck = function () {
        // Only allow one health check at a time.
        if (this.uploadStatus.healthCheckRunning === true) {
            return;
        }
        this.uploadStatus.healthCheckRunning = true;
        this.log('Health check: ' + utils_1.toTimeString(new Date()));
        // If the we are not uploading there's nothing to check.
        if (!this.isUploadInProgress()) {
            this.log('Upload is not in progress. Stopping health check.');
            this.uploadStatus.healthCheckRunning = false;
            return;
        }
        // Look at the current queue and determine if there's pending work
        if (this.uploadStatus.chunkQueue.length === 0 && this.uploadStatus.workers.length === 0) {
            this.uploadStatus.endTime = new Date();
            this.finishUpload();
        }
        else {
            // Calculate the current chunk age and see if its considered as stale.
            var now = new Date();
            var stuckChunks = [];
            for (var _i = 0, _a = this.uploadStatus.inflightChunks; _i < _a.length; _i++) {
                var inflightChunks = _a[_i];
                // If a chunk has exceeded its maximum time to live we assume it has
                // become stale, proceed to terminate it and create a replacement
                var ageInSeconds = (now.getTime() - inflightChunks.getStarted().getTime()) / 1000;
                if (ageInSeconds > const_1.maxWorkerAgeInSeconds) {
                    stuckChunks.push(inflightChunks);
                }
            }
            for (var _b = 0, stuckChunks_1 = stuckChunks; _b < stuckChunks_1.length; _b++) {
                var stuckChunk = stuckChunks_1[_b];
                this.removeInflightChunk(stuckChunk.getChunkNumber());
                this.uploadStatus.chunkQueue.push(stuckChunk.getChunkNumber());
                // Replace the stuck worker with a new one.
                this.removeWorker(stuckChunk.getWorker());
                this.startWorker();
                // Keep track of the amount of replaced workers.
                this.uploadStatus.workerErrorCount++;
            }
        }
        if (this.uploadStatus.workers.length === 0 && this.uploadStatus.chunkQueue.length > 0) {
            this.initWorkers();
        }
        this.uploadStatus.healthCheckRunning = false;
        setTimeout(this.healthCheck.bind(this), 5 * 1000);
    };
    MultiThreadUploadController.prototype.stopAllWorkers = function () {
        this.log('Stopping all workers.');
        // Invoke the terminate method of the worker 
        // which immediately stops all processing
        for (var _i = 0, _a = this.uploadStatus.workers; _i < _a.length; _i++) {
            var worker = _a[_i];
            worker.kill();
            break;
        }
        // Once all workers have stopped lets reset the collection.
        this.uploadStatus.workers = [];
        this.uploadStatus.inflightChunks = [];
    };
    MultiThreadUploadController.prototype.removeInflightChunk = function (chunkNumber) {
        var _this = this;
        this.uploadStatus.inflightChunks.forEach(function (inflightChunk, index) {
            if (inflightChunk.getChunkNumber() === chunkNumber) {
                _this.uploadStatus.inflightChunks.splice(index, 1);
            }
        });
    };
    MultiThreadUploadController.prototype.removeWorker = function (workerToRemove) {
        var _this = this;
        this.uploadStatus.workers.forEach(function (worker, index) {
            if (workerToRemove === worker) {
                _this.log('Worker stopped.');
                worker.kill();
                _this.uploadStatus.workers.splice(index, 1);
            }
        });
    };
    MultiThreadUploadController.prototype.initWorkers = function () {
        // Mark the current upload as in progress
        this.setState(types_1.FileUploadServiceState.Uploading);
        // Kill all existing workers (if any)
        if (this.uploadStatus.workers.length > 0) {
            this.stopAllWorkers();
        }
        // Calculate the number of worker threads to use
        var numberOfWorkers = Math.min(this.uploadData.uploaders, this.uploadStatus.chunkQueue.length);
        this.log("# of workers needed: " + numberOfWorkers);
        for (var i = 0; i < numberOfWorkers; i++) {
            // Stagger worker creation to avoid startup contention
            this.startWorker();
        }
    };
    MultiThreadUploadController.prototype.setupWorker = function () {
        var _this = this;
        var worker = cluster.fork();
        worker.on("message", function (msg) {
            if (typeof msg.event.loaded === "number") {
                if (!_this.uploadData.onProgressChanged) {
                    return;
                }
                _this.reportEventProgress(msg.chunkNumber, msg.event);
            }
            else {
                if (msg.error === true) {
                    // The chunk was not uploaded successfully
                    // get it back on the queue for retry
                    _this.uploadStatus.chunkQueue.push(msg.chunkNumber);
                    _this.log("Upload for chunk #: " + msg.chunkNumber + " failed and will be retried.");
                }
                else {
                    _this.removeInflightChunk(msg.chunkNumber);
                    // Successful upload, mark completion and discard the chunk.
                    _this.uploadStatus.blocksCompleted++;
                }
                // Dispatch the worker instance again to keep processing
                _this.dispatchWorker(worker);
            }
        });
        worker.on("error", function (error) {
            // chunk data is lost, as is chunk number, relying on the finalize to catch this
            _this.log('Worker crashed. Recovering...');
            // Dispatch the worker instance again to keep processing
            _this.dispatchWorker(worker);
        });
        return worker;
    };
    MultiThreadUploadController.prototype.startWorker = function () {
        var worker = this.setupWorker();
        // add the new worker to the pool
        this.uploadStatus.workers.push(worker);
        this.log('Worker started at: ' + utils_1.toTimeString(new Date()));
        // start the upload process on the worker
        this.dispatchWorker(worker);
    };
    MultiThreadUploadController.prototype.dispatchWorker = function (worker) {
        var _this = this;
        // if we are done then call finished and return
        if (this.uploadStatus.chunkQueue.length === 0) {
            this.removeWorker(worker);
            this.log('Worker finished.');
            return;
        }
        // if we are not uploading chunks there is nothing to do.
        if (this.uploadStatus.state !== types_1.FileUploadServiceState.Uploading) {
            return;
        }
        var chunkToSend = this.uploadStatus.chunkQueue.pop();
        // If other worker beat us to grab a chunk we're done
        if (chunkToSend === undefined) {
            return;
        }
        // Otherwise just start processing and uploading the chunk
        var parsedUrl = urlParse(this.uploadData.uploadDomain
            + types_1.UploadBaseUrls.UploadChunk
            + this.uploadData.assetId, true);
        parsedUrl.query["block_number"] = chunkToSend;
        parsedUrl.query["token"] = this.uploadData.token;
        // Track the current chunk as in-flight.
        this.uploadStatus.inflightChunks.push(new types_1.InflightModelChunk(chunkToSend, worker));
        utils_1.getChunk(chunkToSend, this.uploadData)
            .then(function (chunk) {
            worker.send({
                method: 'POST',
                chunk: chunk,
                chunkNumber: chunkToSend,
                url: parsedUrl.toString(),
                correlationId: _this.uploadData.correlationId,
                correlationVector: _this.uploadData.correlationVector
            });
        });
    };
    return MultiThreadUploadController;
}(controller_1.default));
exports.default = MultiThreadUploadController;
//# sourceMappingURL=multi-thread-uploader.js.map